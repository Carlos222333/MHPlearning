当下的程序员应该都听过"面向对象编程"
比较正式的说法 : 
"把一组数据结构和处理它们的方法组成对象（object），把相同行为的对象归纳为类（class），通过类的封装（encapsulation）隐藏内部细节，通过继承（inheritance）实现类的特化（specialization）和泛化（generalization），通过多态（polymorphism）实现基于对象类型的动态分派。"

"**程序是指令的集合**"，
在程序中的语句在执行时会变成一条或多条指令后由CPU去执行。

所谓编程就是程序员按照计算机的工作方式控制计算机完成各种任务。
但计算机的工作方式与正常人类的思维模式是不同的，

如果编程就得抛弃人类正常的思维方式去迎合计算机，编程的乐趣就少了很多
重要的是当需要开发复杂的系统时，代码的复杂性会让开发和维护工作都变得极难，
所以在上世纪60年代末期，"[软件危机](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%8D%B1%E6%9C%BA)"、"[软件工程](https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B)"等一系列的概念开始在行业中出现。

现实中并没有解决这些问题的让人一劳永逸的"[银弹](https://zh.wikipedia.org/wiki/%E6%B2%A1%E6%9C%89%E9%93%B6%E5%BC%B9)"，
真正让软件开发者看到希望的是上世纪70年代诞生的[Smalltalk](https://zh.wikipedia.org/wiki/Smalltalk)编程语言中引入的面向对象的编程思想（面向对象编程的雏形可以追溯到更早期的[Simula](https://zh.wikipedia.org/wiki/Simula)语言）。
按照这种编程理念，程序中的数据和操作数据的函数是一个逻辑上的整体，称之为“对象”
解决方式就是创建出需要的对象并向对象发出各种各样的消息，多个对象的协同工作最终可以构造出复杂的系统来解决现实中的问题。

# 类和对象
简单的说，类是对象的蓝图和模板，而对象是类的实例。
类是抽象的概念，而对象是具体的东西。
在面向对象编程的世界中，一切皆为对象，对象都有属性和行为，每个对象都是独一无二的，而且对象一定属于某个类（型）。
把拥有共同特征的对象的静态特征（属性）和动态特征（行为）都抽取出来后，就可以定义出一个叫做“类”的东西。

## 定义类和对象
用`class`关键字定义类，
在类中通过函数来定义方法，方法描述对象的动态特征，
如下
```python
class Student(object):

    # __init__是一个特殊方法用于在创建对象时进行初始化操作
    # 通过这个方法我们可以为学生对象绑定name和age两个属性
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def study(self, course_name):
        print('%s正在学习%s.' % (self.name, course_name))

    # PEP 8要求标识符的名字用全小写多个单词用下划线连接
    # 但是部分程序员和公司更倾向于使用驼峰命名法(驼峰标识)
    def think(self):
        if self.age < 18:
            print('%s正在渴望成绩.' % self.name)
        else:
            print('%s正在渴望爱情.' % self.name)

```
> **说明：** 写在类中的函数，通常称之为（对象的）方法，这些方法就是对象可以接收的参数。

## 创建和使用对象
定义类后，可以创建对象并给对象发消息
```python
def main():
    # 创建学生对象并指定姓名和年龄
    stu1 = Student('李白', 1000)
    # 给对象发study参数
    stu1.study('Python程序设计')
    # 给对象发think
    stu1.think()
    stu2 = Student('王大锤', 15)
    stu2.study('思想品德')
    stu2.think()


if __name__ == '__main__':
    main()
```

## 访问可见性问题
有C++、Java、C#等编程经验的程序员可能会问，
给`Student`对象绑定的`name`和`age`属性访问权限(也称可见性)是怎么样的。

在很多面向对象编程语言中，
通常会将对象的属性设置为私有的（private）或受保护的（protected），不允许外界访问，
对象的方法通常都是公开的（public），公开的方法就是对象能够接收的
Python中，属性和方法的访问权限只有两种，公开的和私有的，

如果设置私有的属性，在给属性命名时可以用两个下划线作为开头
```python
class Test:

    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print('__bar')


def main():
    test = Test('hello')
    # AttributeError: 'Test' object has no attribute '__bar'
    test.__bar()
    # AttributeError: 'Test' object has no attribute '__foo'
    print(test.__foo)


if __name__ == "__main__":
    main()
```
但Python没有从语法上严格保证私有属性或方法的私密性，它只是给私有的属性和方法换了一个名字来妨碍对它们的访问，

事实上如果知道更换名字的规则仍然可以访问到它们，下面的代码就可以验证这一点。
```python
class Test:

    def __init__(self, foo):
        self.__foo = foo

    def __bar(self):
        print(self.__foo)
        print('__bar')


def main():
    test = Test('hello')
    test._Test__bar()
    print(test._Test__foo)


if __name__ == "__main__":
    main()
```
之所以这样设定，是因为实际开发中，不建议将属性设置为私有的，因为会导致子类无法访问（后面会讲到）。
可以用这样一句名言加以解释，就是"**We are all consenting adults here**"(我们都是成年人)
表达了很多Python程序员的一个共同观点，"**开放比封闭要好**"，我们应该自己对自己的行为负责而不是从语言层面来限制对数据或方法的访问。

所以在Python中实在没有必要将类中的属性或方法用双下划线开头的命名处理成私有的成员，因为这并没有任何实际的意义。
如果想对属性或方法进行保护，更建议用单下划线开头的受保护成员，虽然它也不能真正保护这些属性或方法，但是它相当于给调用者一个暗示，让调用者知道这是不应该直接访问的属性或方法，而且这样做并不影响子类去继承这些东西。

注意 : Python类中的那些魔法方法，如`__str__`、`__repr__`等，这些方法并不是私有成员，虽然它们以双下划线开头，但是他们也是以双下划线结尾的，这种命名并不是私有成员的命名


## 面向对象的支柱
面向对象有三大支柱：
* 封装
* 继承
* 多态
什么是封装：

对封装的理解是"隐藏一切可以隐藏的实现细节，只向外界暴露（提供）简单的编程接口"。
在类中定义的方法其实就是把数据和对数据的操作封装起来了，
在创建了对象之后，只需要给对象发送一个参数（调用方法）就可以执行方法中的代码，
只需要知道方法的名字和传入的参数（方法的外部视图），
而不需要知道方法内部的实现细节（方法的内部视图）。











