以一道数学题开场：
下面的方程有多少组正整数解。 $$ x_1 + x_2 + x_3 + x_4 = 8 $$ 
这个问题等同于将`8`个苹果分成四组且每组至少一个苹果有多少种方案，问题还可以进一步等价于在分隔`8`个苹果的`7`个空隙之间插入三个隔板将苹果分成四组有多少种方案，也就是从`7`个空隙选出`3`个空隙放入隔板的组合数，所以答案是$$C_7^3=35$$ 。组合数的计算公式如下

$$ C_M^N = \frac {M!} {N!(M-N)!} $$ 

根据所学知识，可以用循环做累乘的方式来计算阶乘，那么通过下面代码就可以计算出组合数$$ C_M^N $$如下
```python
m = int(input('m = '))
n = int(input('n = '))
# 计算m的阶乘
fm = 1
for num in range(1, m + 1):
    fm *= num
# 计算n的阶乘
fn = 1
for num in range(1, n + 1):
    fn *= num
# 计算m-n的阶乘
fk = 1
for num in range(1, m - n + 1):
    fk *= num
# 计算C(M,N)的值
print(fm // fn // fk)
```
# 函数的作用
注意:：上例中做了三次求阶乘，虽然`m`、`n`、`m - n`的值各不相同，但是三段代码并没有实质性的区别，属于重复代码。
世界级的编程大师Martin Fowler先生曾说：“**代码有很多种坏味道，重复是最坏的一种！**”

所以要写出高质量代码首先要解决重复代码的问题。对于上例，可以将计算阶乘的功能封装到一个称为“函数”的代码块中，计算阶乘时只需要“调用函数”就可以了。

# 定义函数
```python
def 函数名（参数）:
    函数体
    return 返回值
```
函数命名规则跟变量的命名规则一致（忘了就回去看）
函数执行完成后可以通过`return`关键字来返回一个值

定义函数对上例代码进行重构，
>重构就是在不影响代码执行结果的前提下对代码的结构进行调整，

重构后代码如下
```python
def fac(num):
    """求阶乘"""
    result = 1
    for n in range(1, num + 1):
        result *= n
    # 返回num的阶乘（因变量）
    return result

m = int(input('m = '))
n = int(input('n = '))
# 当需要计算阶乘的时候不用再写重复的代码而是直接调用函数fac
# 调用函数的语法是在函数名后面跟上圆括号并传入参数
print(fac(m) // fac(n) // fac(m - n))
```
> **说明：** Python标准库的`math`模块中已有一个名为`factorial`函数实现了阶乘运算的功能，不用自己再写，这里是为了讲解才又实现了一遍，**实际开发中并不建议做这种低级的重复劳动（很傻）**。

函数内的第一条语句是字符串，是文档字符串，也称为 _docstring_，详见 [文档字符串](https://docs.python.org/zh-cn/3/tutorial/controlflow.html#tut-docstrings)。
利用文档字符串可以自动生成在线文档或打印版文档，还可以让开发者在浏览代码时直接查阅文档；
Python 开发者最好养成在代码中加入文档字符串的好习惯。

# 函数详解
## 函数的参数
绝大多数编程语言中都支持函数，
但是Python与其他语言中的函数有很多不太相同的地方，
一个显著的区别就是Python对函数**参数**的处理。
Python中，函数的参数可以有默认值，也支持使用可变参数

所以Python并不需要像其他语言一样支持[函数的重载](https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD)，

### 默认参数
为参数指定默认值是非常有用的方式

如果函数中没有`return`语句，那么函数默认返回代表空值的`None`

在调用函数的时候，如果没有传入对应参数的值时，将使用该参数的默认值

一个简单的例子：
```python
def add(a=0, b=0, c=0):
    """三个数相加求和"""
    return a + b + c

# 调用add函数，没有传入参数，那么a、b、c都使用默认值0
print(add())         # 0
# 调用add函数，传入一个参数，那么该参数赋值给变量a, 变量b和c使用默认值0
print(add(1))        # 1
# 调用add函数，传入两个参数，1和2分别赋值给变量a和b，变量c使用默认值0
print(add(1, 2))     # 3
# 调用add函数，传入三个参数，分别赋值给a、b、c三个变量
print(add(1, 2, 3))  # 6
# 传递参数时可以不按照设定的顺序进行传递，但是要用“参数名=参数值”的形式
print(add(c=50, a=100, b=200))    # 350
```
> **注意**：带默认值的参数必须放在不带默认值的参数之后，否则将产生`SyntaxError`错误，错误消息是：`non-default argument follows default argument`，翻译成中文的意思是“没有默认值的参数放在了带默认值的参数后面”。

默认参数在定义作用域的函数定义中求值
意味着它们在函数定义时就被求值，而不是在函数调用时。
```python
i = 1 

def f(arg = i)
    print(arg)
i = 1000
f()#此处函数输出的是1而不是1000
```

**重要警告： 默认值只计算一次**

但默认值为列表、字典或类实例等可变对象时，会产生与该规则不同的结果

例如，下面的函数会累积后续调用时传递的参数：
```python
def f(a, L=[]):
    L.append(a)
    return L

print(f(1))
print(f(2))
print(f(3))
```
输出：
[1]
[1, 2]
[1, 2, 3]
如果不想在后续调用之间共享默认值时，用以下方式写函数：
```python
def f(a, l=None):  
    if l is None:  
        l = []  
    l.append(a)  
    return l
```
所以上面代码中可以用不同的方式去调用`add`函数，
这跟其他很多语言中函数重载的效果是一致的

### 可变参数
add函数更好的实现方案：
因为可能会对0个或多个参数进行加法运算，
而具体有多少个参数是由调用者来决定，

作为函数的设计者在不确定参数个数的时候，
可以使用**可变参数**
如下
```python
# 用星号表达式来表示args可以接收0个或任意多个参数
def add(*args):
    total = 0
    # 可变参数可以放在for循环中取出每个参数的值
    for val in args:
        if type(val) in (int, float):
            total += val
    return total

# 在调用add函数时可以传入0个或任意多个参数
print(add())
print(add(1))
print(add(1, 2))
print(add(1, 2, 3))
print(add(1, 3, 5, 7, 9))
```

# 模块管理函数
不管用什么样的编程语言来写代码，给变量、函数起名都是一个头疼的问题，

因为会遇到**命名冲突**这种尴尬的情况。最简单的场景就是在同一个`.py`文件中定义了两个同名的函数，
如下
```python
def foo():
    print('hello, world!')


def foo():
    print('goodbye, world!')

# 下面的函数会输出goodbye, world!
foo()
```
>由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。

个人开发时很容易就能避免，
但如果项目进行团队开发的时，
团队中可能有多个程序员都定义了名为`foo`的函数，

那么怎么解决这种命名冲突呢？

简单
Python中每个文件就代表了一个模块（module），在不同的模块中可以有同名的函数，

使用函数时通过`import`关键字导入指定模块就可以区分到底要使用的是哪个模块中的`foo`函数，代码如下所示
`module1.py`
```python
def foo():
	print('helloworld')
```
`module2.py`
```python
def foo():
	print('goodbyeworld')
```
`test.py`
```python
from module1 import foo

# 输出hello, world!
foo()

from module2 import foo

# 输出goodbye, world!
foo()
```

导入模块时可以用as关键字对模块进行别名，可以使用更为简短的完全限定名
`test.py`
```python
import module1 as m1
import module2 as m2

m1.foo()
m2.foo()
```

但如果从两个不同模块中导入了同名函数，后导入的函数会覆盖掉先前的导入，

下例中，调用`foo`会输出`hello, world!`，因为先导入了`module2`的`foo`，后导入了`module1`的`foo` 。如果两个`from...import...`反过来写，就是另外一种情况：
`test.py`
```python
from module2 import foo
from module1 import foo

# 输出hello, world!
foo()
```
`test.py`
```python
from module1 import foo
from module2 import foo
# 输出goodbye, world!
foo()
```

**说明**：如果导入的模块除了定义函数之外还有可执行代码，
那么Python解释器在导入这个模块时就会执行这些代码，

事实上开发者可能并不希望如此，
因此如果模块中编写了执行代码，
最好是将这些执行代码放入如下所示的条件中，
`module3.py`
```python
def foo():
    pass

def bar():
    pass

if __name__ == '__main__':
    print('call foo()')
    foo()
    print('call bar()')
    bar()
```
这样的话除非直接运行该模块，
if条件下的这些代码是不会执行的，
因为只有直接执行的模块的名字才是"__main__"。

`test.py`
```python
import module3

# 导入module3时 
# 不会执行模块中if条件成立时的代码 
# 因为模块的名字是module3而不是__main__
```

# 标准库中的模块和函数
Python标准库中提供了大量的模块和函数来简化开发工作，实际开发中并不需要自己编写，而`math`模块中还包括了计算正弦、余弦、指数、对数等一系列的数学函数。随着进一步的学习编程知识，还会用到更多的模块和函数。

还有一类函数是不需要`import`就能够直接使用的，将其称之为内置函数，

内置函数都是很有用也是最常用的，下表列出了一部分的内置函数。

|函数|说明|
|---|---|
|`abs`|返回一个数的绝对值，例如：`abs(-1.3)`会返回`1.3`。|
|`bin`|把一个整数转换成以`'0b'`开头的二进制字符串，例如：`bin(123)`会返回`'0b1111011'`。|
|`chr`|将Unicode编码转换成对应的字符，例如：`chr(8364)`会返回`'€'`。|
|`hex`|将一个整数转换成以`'0x'`开头的十六进制字符串，例如：`hex(123)`会返回`'0x7b'`。|
|`input`|从输入中读取一行，返回读到的字符串。|
|`len`|获取字符串、列表等的长度。|
|`max`|返回多个参数或一个可迭代对象中的最大值，例如：`max(12, 95, 37)`会返回`95`。|
|`min`|返回多个参数或一个可迭代对象中的最小值，例如：`min(12, 95, 37)`会返回`12`。|
|`oct`|把一个整数转换成以`'0o'`开头的八进制字符串，例如：`oct(123)`会返回`'0o173'`。|
|`open`|打开一个文件并返回文件对象。|
|`ord`|将字符转换成对应的Unicode编码，例如：`ord('€')`会返回`8364`。|
|`pow`|求幂运算，例如：`pow(2, 3)`会返回`8`；`pow(2, 0.5)`会返回`1.4142135623730951`。|
|`print`|打印输出。|
|`range`|构造一个范围序列，例如：`range(100)`会产生`0`到`99`的整数序列。|
|`round`|按照指定的精度对数值进行四舍五入，例如：`round(1.23456, 4)`会返回`1.2346`。|
|`sum`|对一个序列中的项从左到右进行求和运算，例如：`sum(range(1, 101))`会返回`5050`。|
|`type`|返回对象的类型，例如：`type(10)`会返回`int`；而 `type('hello')`会返回`str`。|

# 简单的总结
**函数是对功能相对独立且会重复使用的代码的封装**。

学会使用定义和使用函数，就能够写出更为优质的代码。标准库中已经为提供了大量的模块和常用的函数，用好这些模块和函数就能够用更少的代码做更多的事情；如果这些模块和函数不能满足要求，就要自定义函数，然后用模块的概念来管理这些自定义函数。